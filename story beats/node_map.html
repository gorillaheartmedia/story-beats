<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Visual Node Editor â€“ Blueprint Grid</title>
  <style>
    body { background: #14213d; color: #eee; font-family: sans-serif; margin: 0; }
    .toolbar { padding: 12px; background: #222; }
    button { margin-right: 10px; padding: 6px 12px; border: none; border-radius: 4px;}
    #mapArea { width: 100vw; height: 80vh; background: #14213d; display: block; border: none; }
    .cfg-panel {
      position: absolute; background: #23272a; border: 1px solid #7ed6df;
      color: #eee; border-radius: 6px; padding: 8px; z-index: 20;
    }
    .cfg-panel label { display: block; margin: 3px 0 1px; }
    .cfg-panel input[type="range"] { width: 80px; }
    .cfg-panel input[type="color"] { width: 40px; height: 24px; border: none; }
    #connectBtn.active { background: #e056fd; color: #222; }
    html, body { height: 100%; width: 100%; overflow: hidden; }
.fab-research {
  position: fixed;
  right: 32px;
  bottom: 32px;
  z-index: 9999;
  width: 62px;
  height: 62px;
  background: linear-gradient(130deg, #4befff 60%, #1958ca 100%);
  border-radius: 50%;
  box-shadow: 0 2px 22px #2b7aff66;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background .14s, box-shadow .12s;
}
.fab-research:hover {
  background: linear-gradient(110deg, #1958ca 40%, #4befff 100%);
  box-shadow: 0 4px 34px #3be3ff99;
}
.fab-research .fab-icon {
  font-size: 2em;
  color: #14283c;
  filter: drop-shadow(0 2px 4px #fffbe933);
  user-select: none;
}
.fab-research:after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 78px;
  right: 0;
  background: #14283ccc;
  color: #fffbb0;
  padding: 6px 16px;
  border-radius: 9px;
  font-size: 1em;
  font-weight: 500;
  pointer-events: none;
  opacity: 0;
  transform: translateY(12px);
  transition: opacity .17s, transform .17s;
  white-space: nowrap;
}
.fab-research:hover:after {
  opacity: 1;
  transform: translateY(0);
}
</style>
<script>
  getProjectId().then(projectId => {
    console.log("Current projectId:", projectId);
    if (!projectId) {
      alert("No project selected!");
      window.location.href = "dashboard.html";
    }
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

</head>
<body>
  <div class="toolbar">
    <button onclick="addNode()">âž• Add Node</button>
    <button onclick="addGroup()">ðŸŸ£ Add Group</button>
    <button id="connectBtn" onclick="toggleConnect()">ðŸ”— Connect</button>
    <button onclick="clearMap()">ðŸ§¹ Clear</button>
    <button onclick="exportToPDF()">ðŸ“„ Export PDF</button>
    <button onclick="saveMap()">ðŸ’¾ Save JSON</button>
    <button onclick="loadMap()">ðŸ“‚ Load JSON</button>
    <input type="file" id="jsonLoader" style="display:none" accept=".json"/>
  </div>
  <div id="zoomHud" style="position:fixed;top:12px;right:18px;z-index:50;
    background:#23272aCC;color:#fff;padding:6px 16px;border-radius:18px;
    font-size:15px;box-shadow:0 2px 8px #0002;display:inline-flex;align-items:center;gap:12px;user-select:none;">
    <span id="zoomPercent">100%</span>
    <button id="resetZoomBtn" style="margin-left:2px;padding:3px 12px;font-size:14px;border-radius:9px;background:#e056fd;color:#222;border:none;cursor:pointer;">Reset</button>
  </div>
  <svg id="mapArea"></svg>
  <div id="cfgPanel" class="cfg-panel" style="display:none"></div>
<script>
let nodes = [];
let edges = [];
let groups = [];
let draggingNode = null, offsetX = 0, offsetY = 0;
let draggingGroup = null, gOffsetX = 0, gOffsetY = 0;
let connecting = false, connectStart = null, connectStartType = null;
let editingNode = null, editingEdge = null, editingGroup = null;
const svg = document.getElementById("mapArea");
svg.setAttribute("width", window.innerWidth);
svg.setAttribute("height", window.innerHeight * 0.8);

// --- ZOOM & PAN ---
let zoom = 1;
let panX = 0;
let panY = 0;
const zoomPercentSpan = document.getElementById('zoomPercent');
const resetZoomBtn = document.getElementById('resetZoomBtn');
function updateZoomDisplay() {
  zoomPercentSpan.textContent = Math.round(zoom * 100) + "%";
}
resetZoomBtn.onclick = function() {
  zoom = 1;
  panX = 0;
  panY = 0;
  redraw();
  updateZoomDisplay();
};
svg.addEventListener('wheel', function(ev) {
  ev.preventDefault();
  const scaleAmount = 1.12;
  const mouseX = ev.offsetX;
  const mouseY = ev.offsetY;
  // Coordinates relative to current transform
  const localX = (mouseX - panX) / zoom;
  const localY = (mouseY - panY) / zoom;

  if (ev.deltaY < 0) { // zoom in
    zoom *= scaleAmount;
  } else { // zoom out
    zoom /= scaleAmount;
  }
  panX = mouseX - localX * zoom;
  panY = mouseY - localY * zoom;

  redraw();
  updateZoomDisplay();
}, { passive: false });

let isPanning = false;
let panOrigin = { x: 0, y: 0 };
let panStart = { x: 0, y: 0 };
svg.addEventListener('mousedown', function(ev) {
  if (ev.button === 2 || (window._panKeyHeld && ev.button === 0)) {
    isPanning = true;
    panOrigin = { x: ev.clientX, y: ev.clientY };
    panStart = { x: panX, y: panY };
    svg.style.cursor = "grab";
    ev.preventDefault();
  }
});
svg.addEventListener('mousemove', function(ev) {
  if (isPanning) {
    const dx = ev.clientX - panOrigin.x;
    const dy = ev.clientY - panOrigin.y;
    panX = panStart.x + dx;
    panY = panStart.y + dy;
    redraw();
    updateZoomDisplay();
  }
});
svg.addEventListener('mouseup', function(ev) {
  if (isPanning) {
    isPanning = false;
    svg.style.cursor = "";
  }
});
svg.addEventListener('mouseleave', function(ev) {
  if (isPanning) {
    isPanning = false;
    svg.style.cursor = "";
  }
});
svg.addEventListener('contextmenu', ev => { if (isPanning) ev.preventDefault(); });
window.addEventListener('keydown', ev => { if (ev.code === 'Space') window._panKeyHeld = true; });
window.addEventListener('keyup', ev => { if (ev.code === 'Space') window._panKeyHeld = false; });

function getIntersection(from, to, shape, width, height) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);

  if (shape === "circle") {
    let r = width || 35;
    return { x: from.x + Math.cos(angle) * r, y: from.y + Math.sin(angle) * r };
  } else if (shape === "hex" || shape === "octagon" || shape === "diamond" || shape === "triangle" || shape === "square") {
    let rx = width || 35, ry = height || 35;
    return { x: from.x + Math.cos(angle) * rx, y: from.y + Math.sin(angle) * ry };
  } else if (shape === "ellipse") {
    let rx = width || 60, ry = height || 40;
    return { x: from.x + rx * Math.cos(angle), y: from.y + ry * Math.sin(angle) };
  } else if (shape === "rect") {
    let rx = width || 60, ry = height || 40;
    let px = Math.sign(dx), py = Math.sign(dy);
    let tx = rx / Math.abs(dx || 0.0001), ty = ry / Math.abs(dy || 0.0001);
    if (tx < ty) {
      return { x: from.x + px * rx, y: from.y + tx * dy };
    } else {
      return { x: from.x + ty * dx, y: from.y + py * ry };
    }
  }
  return { x: from.x, y: from.y };
}

let connectButton = document.getElementById('connectBtn');
function toggleConnect() {
  connecting = !connecting;
  if (connecting) {
    connectStart = null;
    connectStartType = null;
    svg.style.cursor = "crosshair";
    connectButton.classList.add('active');
  } else {
    connectStart = null;
    connectStartType = null;
    svg.style.cursor = "";
    connectButton.classList.remove('active');
  }
}

function getSVGCoords(ev) {
  const pt = svg.createSVGPoint();
  pt.x = ev.clientX;
  pt.y = ev.clientY;
  const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
  return { x: svgP.x, y: svgP.y };
}

function handleConnectClick(ev) {
  const coords = getSVGCoords(ev);
  const nodeIdx = getNodeAt(coords.x, coords.y);
  const groupIdx = getGroupAt(coords.x, coords.y);

  let pickedType = null, pickedIdx = null;
  if (nodeIdx !== null && nodeIdx !== -1) { pickedType = "node"; pickedIdx = nodeIdx; }
  else if (groupIdx !== null && groupIdx !== -1) { pickedType = "group"; pickedIdx = groupIdx; }

  if (pickedIdx !== null) {
    if (connectStart === null) {
      connectStart = pickedIdx;
      connectStartType = pickedType;
    } else if (connectStartType !== null) {
      if (!(connectStart === pickedIdx && connectStartType === pickedType)) {
        edges.push({
          from: connectStart,
          fromType: connectStartType,
          to: pickedIdx,
          toType: pickedType,
          label: "",
          color: "#7ed6df",
          thick: 3,
          style: "solid",
          arrow: true
        });
        connectStart = null;
        connectStartType = null;
        toggleConnect();
        redraw();
        updateZoomDisplay();
      }
    }
  }
}

function addGroup() {
  groups.push({
    x: 250,
    y: 250,
    rx: 110,
    ry: 70,
    color: "#e056fd",
    label: "Group",
    z: Date.now(),
    shape: "ellipse",
    customData: ""
  });
  redraw();
  updateZoomDisplay();
}
function drawGroup(g, selected) {
  const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
  let shapeElem;
  const color = g.color + "40";
  const stroke = selected ? "#fff" : g.color;
  if (g.shape === "rect") {
    shapeElem = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    shapeElem.setAttribute("x", g.x - g.rx);
    shapeElem.setAttribute("y", g.y - g.ry);
    shapeElem.setAttribute("width", g.rx * 2);
    shapeElem.setAttribute("height", g.ry * 2);
    shapeElem.setAttribute("rx", 16);
    shapeElem.setAttribute("fill", color);
    shapeElem.setAttribute("stroke", stroke);
    shapeElem.setAttribute("stroke-width", 4);
  } else if (g.shape === "hex") {
    let points = [];
    for(let i=0; i<6; i++) {
      let angle = Math.PI/3 * i;
      points.push((g.x + g.rx*Math.cos(angle)) + "," + (g.y + g.ry*Math.sin(angle)));
    }
    shapeElem = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    shapeElem.setAttribute("points", points.join(" "));
    shapeElem.setAttribute("fill", color);
    shapeElem.setAttribute("stroke", stroke);
    shapeElem.setAttribute("stroke-width", 4);
  } else if (g.shape === "octagon") {
    let points = [];
    for(let i=0; i<8; i++) {
      let angle = Math.PI/4 * i + Math.PI/8;
      points.push((g.x + g.rx * Math.cos(angle)) + "," + (g.y + g.ry * Math.sin(angle)));
    }
    shapeElem = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    shapeElem.setAttribute("points", points.join(" "));
    shapeElem.setAttribute("fill", color);
    shapeElem.setAttribute("stroke", stroke);
    shapeElem.setAttribute("stroke-width", 4);
  } else if (g.shape === "diamond") {
    let points = [
      (g.x) + "," + (g.y - g.ry),
      (g.x + g.rx) + "," + (g.y),
      (g.x) + "," + (g.y + g.ry),
      (g.x - g.rx) + "," + (g.y)
    ];
    shapeElem = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    shapeElem.setAttribute("points", points.join(" "));
    shapeElem.setAttribute("fill", color);
    shapeElem.setAttribute("stroke", stroke);
    shapeElem.setAttribute("stroke-width", 4);
  } else { // ellipse default
    shapeElem = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    shapeElem.setAttribute("cx", g.x);
    shapeElem.setAttribute("cy", g.y);
    shapeElem.setAttribute("rx", g.rx);
    shapeElem.setAttribute("ry", g.ry);
    shapeElem.setAttribute("fill", color);
    shapeElem.setAttribute("stroke", stroke);
    shapeElem.setAttribute("stroke-width", 4);
  }
  group.appendChild(shapeElem);
  const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
  t.setAttribute("x", g.x);
  t.setAttribute("y", g.y);
  t.setAttribute("font-size", 20);
  t.setAttribute("font-family", "sans-serif");
  t.setAttribute("text-anchor", "middle");
  t.setAttribute("fill", "#fff");
  t.textContent = g.label;
  group.appendChild(t);

  group.onclick = ev => {
    if (connecting) {
      handleConnectClick(ev);
      ev.stopPropagation();
    } else {
      ev.stopPropagation();
    }
  };
  group.ondblclick = ev => { if (!connecting) showGroupPanel(groups.indexOf(g), ev); };
  group.onmousedown = ev => { if (!connecting) startDragGroup(ev, groups.indexOf(g)); };
  return group;
}
function startDragGroup(ev, i) {
  draggingGroup = i;
  gOffsetX = ev.offsetX - groups[i].x;
  gOffsetY = ev.offsetY - groups[i].y;
  svg.onmousemove = dragGroup;
  svg.onmouseup = stopDragGroup;
}
function dragGroup(ev) {
  if (draggingGroup !== null) {
    groups[draggingGroup].x = ev.offsetX - gOffsetX;
    groups[draggingGroup].y = ev.offsetY - gOffsetY;
    redraw();
    updateZoomDisplay();
  }
}
function stopDragGroup() {
  draggingGroup = null;
  svg.onmousemove = null;
  svg.onmouseup = null;
}
function showGroupPanel(i, ev) {
  editingGroup = i;
  editingNode = null;
  editingEdge = null;
  const g = groups[i];
  cfgPanel.style.display = "block";
  cfgPanel.style.left = (g.x + 20) + "px";
  cfgPanel.style.top = (g.y + 20) + "px";
  cfgPanel.innerHTML = `
    <b>Group Settings</b><br>
    <label>Name: <input type="text" id="gLabel" value="${g.label}" /></label>
    <label>Color: <input type="color" id="gColor" value="${g.color}" /></label>
    <label>Shape:
      <select id="gShape">
        <option value="ellipse"${g.shape==="ellipse"?" selected":""}>Ellipse</option>
        <option value="rect"${g.shape==="rect"?" selected":""}>Rectangle</option>
        <option value="hex"${g.shape==="hex"?" selected":""}>Hexagon</option>
        <option value="octagon"${g.shape==="octagon"?" selected":""}>Octagon</option>
        <option value="diamond"${g.shape==="diamond"?" selected":""}>Diamond</option>
      </select>
    </label>
    <label>Width: <input type="range" min="30" max="350" id="gRX" value="${g.rx}" /></label>
    <label>Height: <input type="range" min="20" max="250" id="gRY" value="${g.ry}" /></label>
    <label>Custom Data:<br>
      <textarea id="gCustomData" rows="3" placeholder="Any notes or data...">${g.customData || ""}</textarea>
    </label>
    <button onclick="saveGroupCfg(${i})">Save</button>
    <button onclick="deleteGroup(${i})" style="color:red">Delete</button>
    <button onclick="closePanel()">Close</button>
  `;
}
function saveGroupCfg(i) {
  const g = groups[i];
  g.label = document.getElementById("gLabel").value;
  g.color = document.getElementById("gColor").value;
  g.shape = document.getElementById("gShape").value;
  g.rx = parseInt(document.getElementById("gRX").value) || 80;
  g.ry = parseInt(document.getElementById("gRY").value) || 50;
  g.customData = document.getElementById("gCustomData").value;
  cfgPanel.style.display = "none";
  redraw();
  updateZoomDisplay();
}
function deleteGroup(i) {
  groups.splice(i, 1);
  cfgPanel.style.display = "none";
  redraw();
  updateZoomDisplay();
}

function addNode() {
  nodes.push({
    x: 120 + Math.random() * (window.innerWidth - 240),
    y: 120 + Math.random() * (window.innerHeight * 0.7 - 200),
    label: "Node",
    color: "#303952",
    shape: "circle",
    width: 35,
    height: 35,
    font: "sans-serif",
    fontSize: 18,
    labelFill: "#fff",
    labelNoFill: false,
    labelBorder: "#23272a",
    labelBorderThick: 0,
    customData: ""
  });
  redraw();
  updateZoomDisplay();
}
function drawNodeShape(n, selected) {
  const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
  let shape;
  const color = n.color || "#303952";
  const width = n.width || n.size || 35;
  const height = n.height || n.size || 35;
  if (n.shape === "square") {
    shape = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    shape.setAttribute("x", n.x - width);
    shape.setAttribute("y", n.y - height);
    shape.setAttribute("width", width * 2);
    shape.setAttribute("height", height * 2);
    shape.setAttribute("rx", 8);
  } else if (n.shape === "hex") {
    let points = [];
    for(let i=0; i<6; i++) {
      let angle = Math.PI/3 * i;
      points.push((n.x + width*Math.cos(angle)) + "," + (n.y + height*Math.sin(angle)));
    }
    shape = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    shape.setAttribute("points", points.join(" "));
  } else if (n.shape === "triangle") {
    let s = Math.max(width, height) * 1.3;
    shape = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    shape.setAttribute("points",
      (n.x) + "," + (n.y - s) + " " +
      (n.x - s * Math.sin(Math.PI/3)) + "," + (n.y + s/2) + " " +
      (n.x + s * Math.sin(Math.PI/3)) + "," + (n.y + s/2)
    );
  } else if (n.shape === "octagon") {
    let points = [];
    for(let i=0; i<8; i++) {
      let angle = Math.PI/4 * i + Math.PI/8;
      points.push((n.x + width * Math.cos(angle)) + "," + (n.y + height * Math.sin(angle)));
    }
    shape = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    shape.setAttribute("points", points.join(" "));
  } else if (n.shape === "diamond") {
    let points = [
      (n.x) + "," + (n.y - height),
      (n.x + width) + "," + (n.y),
      (n.x) + "," + (n.y + height),
      (n.x - width) + "," + (n.y)
    ];
    shape = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    shape.setAttribute("points", points.join(" "));
  } else {
    shape = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    shape.setAttribute("cx", n.x);
    shape.setAttribute("cy", n.y);
    shape.setAttribute("rx", width);
    shape.setAttribute("ry", height);
  }
  shape.setAttribute("fill", color);
  shape.setAttribute("stroke", selected ? "#e056fd" : "#fff");
  shape.setAttribute("stroke-width", 3);
  group.appendChild(shape);

  if(n.imgData){
    const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
    image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', n.imgData);
    image.setAttribute("x", n.x - width*0.8);
    image.setAttribute("y", n.y - height*0.8);
    image.setAttribute("width", width*1.6);
    image.setAttribute("height", height*1.6);
    image.setAttribute("clip-path", "circle(50%)");
    group.appendChild(image);
  }

  const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
  t.setAttribute("x", n.x);
  t.setAttribute("y", n.y + 6);
  t.setAttribute("font-size", (n.fontSize || 18));
  t.setAttribute("font-family", n.font || "sans-serif");
  t.setAttribute("text-anchor", "middle");
  t.setAttribute("pointer-events", "none");
  if(n.labelNoFill) t.setAttribute("fill", "none");
  else t.setAttribute("fill", n.labelFill || "#fff");
  if(n.labelBorderThick>0)
    t.setAttribute("stroke", n.labelBorder || "#23272a"),
    t.setAttribute("stroke-width", n.labelBorderThick);
  else
    t.setAttribute("stroke", "none");
  t.textContent = n.label || "Node";
  group.appendChild(t);

  group.onmousedown = ev => { if (!connecting) startDrag(ev, nodes.indexOf(n)); };
  group.ondblclick = ev => { if (!connecting) showCfgPanel(nodes.indexOf(n), ev); };
  group.onclick = ev => {
    if (connecting) {
      handleConnectClick(ev);
      ev.stopPropagation();
    }
  };
  return group;
}

function drawEdge(e, selected) {
  let n1 = (e.fromType === "node") ? nodes[e.from] : groups[e.from];
  let n2 = (e.toType === "node") ? nodes[e.to] : groups[e.to];
  if (!n1 || !n2) return document.createComment("invalid edge");

  let fromPt, toPt;
  const width1 = n1.width || n1.rx || n1.size || 35, height1 = n1.height || n1.ry || n1.size || 35;
  const width2 = n2.width || n2.rx || n2.size || 35, height2 = n2.height || n2.ry || n2.size || 35;
  const dx = n2.x - n1.x, dy = n2.y - n1.y;
  const dist = Math.hypot(dx, dy);

  let edgeElem, hitElem, pathData = "";

  if (e.style === "cubic") {
    function getTopPoint(obj) {
      if (obj.shape === "ellipse") {
        return { x: obj.x, y: obj.y - (obj.ry || obj.height || obj.size || 40) };
      } else if (obj.shape === "rect") {
        return { x: obj.x, y: obj.y - (obj.ry || obj.height || obj.size || 40) };
      } else {
        return { x: obj.x, y: obj.y - (obj.height || obj.size || 35) };
      }
    }
    const start = getTopPoint(n1);
    const end = getTopPoint(n2);
    const verticalSwoop = Math.max(80, Math.abs(end.y - start.y) * 0.6, Math.abs(end.x - start.x) * 0.3);

    const c1x = start.x;
    const c1y = start.y - verticalSwoop;

    const c2x = end.x;
    const c2y = end.y - verticalSwoop;

    pathData = `M${start.x},${start.y} C${c1x},${c1y} ${c2x},${c2y} ${end.x},${end.y}`;
    edgeElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
    edgeElem.setAttribute("d", pathData);

  } else {
    fromPt = getIntersection(n1, n2, n1.shape, width1, height1);
    toPt = getIntersection(n2, n1, n2.shape, width2, height2);

    if (e.style === "zigzag") {
      let zigzagPath = "";
      const steps = Math.max(Math.floor(dist / 16), 3);
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = fromPt.x + t * (toPt.x - fromPt.x);
        const y = fromPt.y + t * (toPt.y - fromPt.y) + (i % 2 === 0 ? -8 : 8);
        zigzagPath += i === 0 ? `M${x},${y}` : `L${x},${y}`;
      }
      pathData = zigzagPath;
      edgeElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
      edgeElem.setAttribute("d", pathData);

    } else if (e.style === "wavy") {
      let wavePath = "";
      const steps = Math.max(Math.floor(dist / 8), 5);
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = fromPt.x + t * (toPt.x - fromPt.x);
        const y = fromPt.y + t * (toPt.y - fromPt.y) + Math.sin(t * Math.PI * 4) * 8;
        wavePath += i === 0 ? `M${x},${y}` : `L${x},${y}`;
      }
      pathData = wavePath;
      edgeElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
      edgeElem.setAttribute("d", pathData);

    } else if (e.style === "curved") {
      const mx = (fromPt.x + toPt.x) / 2;
      const my = (fromPt.y + toPt.y) / 2;
      const nx = -(toPt.y - fromPt.y) / dist, ny = (toPt.x - fromPt.x) / dist;
      const controlX = mx + nx * 0.55 * dist;
      const controlY = my + ny * 0.55 * dist;
      pathData = `M${fromPt.x},${fromPt.y} Q${controlX},${controlY} ${toPt.x},${toPt.y}`;
      edgeElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
      edgeElem.setAttribute("d", pathData);

    } else {
      edgeElem = document.createElementNS("http://www.w3.org/2000/svg", "line");
      edgeElem.setAttribute("x1", fromPt.x);
      edgeElem.setAttribute("y1", fromPt.y);
      edgeElem.setAttribute("x2", toPt.x);
      edgeElem.setAttribute("y2", toPt.y);
      if (e.style === "dashed") edgeElem.setAttribute("stroke-dasharray", "8,4");
      if (e.style === "dotted") edgeElem.setAttribute("stroke-dasharray", "2,8");
    }
  }

  edgeElem.setAttribute("stroke", e.color || "#7ed6df");
  edgeElem.setAttribute("stroke-width", e.thick || 3);
  edgeElem.setAttribute("fill", "none");
  if (e.arrow && !(e.style === "zigzag" || e.style === "wavy" || e.style === "curved" || e.style === "cubic"))
    edgeElem.setAttribute("marker-end", "url(#arrow)");
  edgeElem.onclick = ev => {
    ev.stopPropagation();
    showEdgeCfgPanel(edges.indexOf(e), ev);
  };

  if (edgeElem.tagName === "line") {
    hitElem = document.createElementNS("http://www.w3.org/2000/svg", "line");
    hitElem.setAttribute("x1", edgeElem.getAttribute("x1"));
    hitElem.setAttribute("y1", edgeElem.getAttribute("y1"));
    hitElem.setAttribute("x2", edgeElem.getAttribute("x2"));
    hitElem.setAttribute("y2", edgeElem.getAttribute("y2"));
  } else {
    hitElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
    hitElem.setAttribute("d", edgeElem.getAttribute("d"));
  }
  hitElem.setAttribute("stroke", "transparent");
  hitElem.setAttribute("stroke-width", (e.thick || 3) + 18);
  hitElem.setAttribute("fill", "none");
  hitElem.setAttribute("pointer-events", "stroke");
  hitElem.style.pointerEvents = "stroke";
  hitElem.onclick = edgeElem.onclick;

  const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
  g.appendChild(hitElem);
  g.appendChild(edgeElem);
  return g;
}

function redraw() {
  svg.setAttribute('viewBox', `${-panX/zoom} ${-panY/zoom} ${svg.clientWidth/zoom} ${svg.clientHeight/zoom}`);
  svg.innerHTML = '';
  const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  const pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
  pattern.setAttribute("id", "bluegrid");
  pattern.setAttribute("width", 40);
  pattern.setAttribute("height", 40);
  pattern.setAttribute("patternUnits", "userSpaceOnUse");

  let minor = document.createElementNS("http://www.w3.org/2000/svg", "path");
  minor.setAttribute("d", "M 40 0 L 0 0 0 40");
  minor.setAttribute("fill", "none");
  minor.setAttribute("stroke", "#235c9f");
  minor.setAttribute("stroke-width", "1");
  pattern.appendChild(minor);

  let major = document.createElementNS("http://www.w3.org/2000/svg", "path");
  major.setAttribute("d", "M 0 0 L 0 40 M 0 0 L 40 0");
  major.setAttribute("fill", "none");
  major.setAttribute("stroke", "#3bc9f3");
  major.setAttribute("stroke-width", "2");
  pattern.appendChild(major);

  defs.appendChild(pattern);

  const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
  marker.setAttribute("id", "arrow");
  marker.setAttribute("markerWidth", "10");
  marker.setAttribute("markerHeight", "10");
  marker.setAttribute("refX", "9");
  marker.setAttribute("refY", "3");
  marker.setAttribute("orient", "auto");
  marker.setAttribute("markerUnits", "strokeWidth");
  marker.innerHTML = '<polygon points="0 0, 10 3, 0 6" fill="#7ed6df"/>';
  defs.appendChild(marker);

  svg.appendChild(defs);

  const grid = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  grid.setAttribute("x", 0);
  grid.setAttribute("y", 0);
  grid.setAttribute("width", "100%");
  grid.setAttribute("height", "100%");
  grid.setAttribute("fill", "#14213d");
  svg.appendChild(grid);

  const gridOverlay = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  gridOverlay.setAttribute("x", 0);
  gridOverlay.setAttribute("y", 0);
  gridOverlay.setAttribute("width", "100%");
  gridOverlay.setAttribute("height", "100%");
  gridOverlay.setAttribute("fill", "url(#bluegrid)");
  gridOverlay.setAttribute("opacity", "0.7");
  svg.appendChild(gridOverlay);

  edges.forEach((e, i) => {
    svg.appendChild(drawEdge(e, editingEdge === i));
    if(e.label) {
      let n1 = (e.fromType === "node") ? nodes[e.from] : groups[e.from];
      let n2 = (e.toType === "node") ? nodes[e.to] : groups[e.to];
      let width1 = n1.width || n1.rx || n1.size || 35, height1 = n1.height || n1.ry || n1.size || 35;
      let width2 = n2.width || n2.rx || n2.size || 35, height2 = n2.height || n2.ry || n2.size || 35;
      let fromPt = getIntersection(n1, n2, n1.shape, width1, height1);
      let toPt = getIntersection(n2, n1, n2.shape, width2, height2);
      const midX = (fromPt.x + toPt.x) / 2;
      const midY = (fromPt.y + toPt.y) / 2;
      const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
      txt.setAttribute("x", midX);
      txt.setAttribute("y", midY - 8);
      txt.setAttribute("fill", "#e056fd");
      txt.setAttribute("text-anchor", "middle");
      txt.textContent = e.label;
      svg.appendChild(txt);
    }
  });
  groups.sort((a,b)=>a.z-b.z).forEach((g, i) => svg.appendChild(drawGroup(g, editingGroup===i)));
  nodes.forEach((n, i) => svg.appendChild(drawNodeShape(n, editingNode === i)));
}

function startDrag(ev, i) {
  draggingNode = i;
  offsetX = ev.offsetX - nodes[i].x;
  offsetY = ev.offsetY - nodes[i].y;
  svg.onmousemove = drag;
  svg.onmouseup = stopDrag;
}
function drag(ev) {
  if (draggingNode !== null) {
    nodes[draggingNode].x = ev.offsetX - offsetX;
    nodes[draggingNode].y = ev.offsetY - offsetY;
    redraw();
    updateZoomDisplay();
  }
}
function stopDrag() {
  draggingNode = null;
  svg.onmousemove = null;
  svg.onmouseup = null;
}

function svgBgClickHandler(ev){ if(!connecting) closePanel(); }
svg.onclick = svgBgClickHandler;

function getNodeAt(x, y) {
  return nodes.findIndex(n => {
    let width = n.width || n.size || 35, height = n.height || n.size || 35;
    if(n.shape === "circle") return Math.hypot(n.x - x, n.y - y) < width;
    if(n.shape === "square") return Math.abs(n.x - x) < width && Math.abs(n.y - y) < height;
    if(n.shape === "triangle" || n.shape === "hex" || n.shape === "octagon" || n.shape === "diamond")
      return Math.abs(n.x - x) < width && Math.abs(n.y - y) < height;
    return false;
  });
}
function getGroupAt(x, y) {
  return groups.findIndex(g => {
    if(g.shape==="ellipse") {
      let dx = (x-g.x)/g.rx, dy = (y-g.y)/g.ry;
      return dx*dx+dy*dy<1;
    }
    if(g.shape==="rect") {
      return x >= g.x-g.rx && x <= g.x+g.rx && y >= g.y-g.ry && y <= g.y+g.ry;
    }
    if(g.shape==="hex" || g.shape==="octagon") {
      let r = Math.max(g.rx, g.ry);
      return Math.hypot(g.x-x, g.y-y) < r;
    }
    if(g.shape==="diamond") {
      let dx = Math.abs(x - g.x), dy = Math.abs(y - g.y);
      return (dx/g.rx + dy/g.ry) <= 1;
    }
    return false;
  });
}

function clearMap() { nodes = []; edges = []; groups = []; redraw(); updateZoomDisplay(); }

const cfgPanel = document.getElementById("cfgPanel");
function showCfgPanel(i, ev) {
  editingNode = i;
  editingEdge = null;
  editingGroup = null;
  const n = nodes[i];
  cfgPanel.style.display = "block";
  cfgPanel.style.left = (n.x + 20) + "px";
  cfgPanel.style.top = (n.y + 20) + "px";
  cfgPanel.innerHTML = `
    <b>Node Settings</b><br>
    <label>Label:
      <input type="text" id="nLabel" value="${n.label || ''}" />
    </label>
    <label>Font:
      <select id="nFont">
        <option value="sans-serif"${n.font==="sans-serif"?" selected":""}>Sans</option>
        <option value="serif"${n.font==="serif"?" selected":""}>Serif</option>
        <option value="monospace"${n.font==="monospace"?" selected":""}>Monospace</option>
        <option value="cursive"${n.font==="cursive"?" selected":""}>Script</option>
      </select>
    </label>
    <label>Font Size: <input type="range" min="10" max="38" step="1" id="nFontSize" value="${n.fontSize||18}" /> <span id="nFontSizeVal">${n.fontSize||18}</span>px</label>
    <label>Label Fill: <input type="color" id="nLabelFill" value="${n.labelFill || "#fff"}" /></label>
    <label><input type="checkbox" id="nLabelNoFill" ${n.labelNoFill?"checked":""}/> No Fill</label>
    <label>Label Border: <input type="color" id="nLabelBorder" value="${n.labelBorder||"#23272a"}" /></label>
    <label>Label Border Thickness: <input type="range" min="0" max="8" step="1" id="nLabelBorderThick" value="${n.labelBorderThick||0}" /> <span id="nLabelBorderThickVal">${n.labelBorderThick||0}</span>px</label>
    <label>Shape:
      <select id="nShape">
        <option value="circle"${n.shape==="circle"?" selected":""}>Circle</option>
        <option value="square"${n.shape==="square"?" selected":""}>Square</option>
        <option value="hex"${n.shape==="hex"?" selected":""}>Hex</option>
        <option value="octagon"${n.shape==="octagon"?" selected":""}>Octagon</option>
        <option value="diamond"${n.shape==="diamond"?" selected":""}>Diamond</option>
        <option value="triangle"${n.shape==="triangle"?" selected":""}>Triangle</option>
      </select>
    </label>
    <label>Width: <input type="range" min="20" max="120" step="1" id="nWidth" value="${n.width || n.size || 35}" /></label>
    <label>Height: <input type="range" min="20" max="120" step="1" id="nHeight" value="${n.height || n.size || 35}" /></label>
    <label>Color: <input type="color" id="nColor" value="${n.color || '#303952'}" /></label>
    <label>Image: <input type="file" id="nImage" accept="image/*" /></label>
    <label>Custom Data:<br>
      <textarea id="nCustomData" rows="3" placeholder="Any notes or data...">${n.customData || ""}</textarea>
    </label>
    <button onclick="saveNodeCfg(${i})">Save</button>
    <button onclick="deleteNode(${i})" style="color:red">Delete</button>
    <button onclick="closePanel()">Close</button>
  `;
  document.getElementById("nFontSize").oninput = function(){
    document.getElementById("nFontSizeVal").innerText = this.value;
  };
  document.getElementById("nLabelBorderThick").oninput = function(){
    document.getElementById("nLabelBorderThickVal").innerText = this.value;
  };
  document.getElementById("nImage").onchange = function() {
    const file = this.files[0];
    if(file){
      const reader = new FileReader();
      reader.onload = function(e){
        n.imgData = e.target.result;
        redraw();
        updateZoomDisplay();
      };
      reader.readAsDataURL(file);
    }
  };
}
function saveNodeCfg(i) {
  const n = nodes[i];
  n.label = document.getElementById("nLabel").value;
  n.font = document.getElementById("nFont").value;
  n.fontSize = parseInt(document.getElementById("nFontSize").value) || 18;
  n.labelFill = document.getElementById("nLabelFill").value;
  n.labelNoFill = document.getElementById("nLabelNoFill").checked;
  n.labelBorder = document.getElementById("nLabelBorder").value;
  n.labelBorderThick = parseInt(document.getElementById("nLabelBorderThick").value) || 0;
  n.shape = document.getElementById("nShape").value;
  n.width = parseInt(document.getElementById("nWidth").value) || 35;
  n.height = parseInt(document.getElementById("nHeight").value) || 35;
  n.color = document.getElementById("nColor").value;
  n.customData = document.getElementById("nCustomData").value;
  cfgPanel.style.display = "none";
  redraw();
  updateZoomDisplay();
}
function deleteNode(i) {
  nodes.splice(i, 1);
  cfgPanel.style.display = "none";
  redraw();
  updateZoomDisplay();
}
function closePanel() {
  editingNode = null; editingEdge = null; editingGroup = null;
  cfgPanel.style.display = "none";
  redraw();
  updateZoomDisplay();
}
function showEdgeCfgPanel(i, ev) {
  editingEdge = i;
  editingNode = null;
  editingGroup = null;
  const e = edges[i];
  const left = (ev.clientX+15)+"px", top = (ev.clientY-40)+"px";
  cfgPanel.style.display = "block";
  cfgPanel.style.left = left; cfgPanel.style.top = top;
  cfgPanel.innerHTML = `
    <b>Edge Settings</b><br>
    <label>Label:<input type="text" id="eLabel" value="${e.label || ''}" /></label>
    <label>Color: <input type="color" id="eColor" value="${e.color || '#7ed6df'}" /></label>
    <label>Thickness: <input type="range" min="1" max="12" id="eThick" value="${e.thick || 3}" /> <span id="eThickVal">${e.thick || 3}</span>px</label>
    <label>Style:
      <select id="eStyle">
        <option value="solid"${e.style==="solid"?" selected":""}>Solid</option>
        <option value="dashed"${e.style==="dashed"?" selected":""}>Dashed</option>
        <option value="dotted"${e.style==="dotted"?" selected":""}>Dotted</option>
        <option value="zigzag"${e.style==="zigzag"?" selected":""}>Zigzag</option>
        <option value="wavy"${e.style==="wavy"?" selected":""}>Wavy</option>
        <option value="curved"${e.style==="curved"?" selected":""}>Curved</option>
        <option value="cubic"${e.style==="cubic"?" selected":""}>Cubic Curve</option>
      </select>
    </label>
    <label><input type="checkbox" id="eArrow" ${e.arrow?"checked":""}/> Arrowhead</label>
    <button onclick="saveEdgeCfg(${i})">Save</button>
    <button onclick="deleteEdge(${i})" style="color:red">Delete</button>
    <button onclick="closePanel()">Close</button>
  `;
  document.getElementById("eThick").oninput = function(){
    document.getElementById("eThickVal").innerText = this.value;
  };
}
function saveEdgeCfg(i){
  const e = edges[i];
  e.label = document.getElementById("eLabel").value;
  e.color = document.getElementById("eColor").value;
  e.thick = parseInt(document.getElementById("eThick").value) || 3;
  e.style = document.getElementById("eStyle").value;
  e.arrow = document.getElementById("eArrow").checked;
  cfgPanel.style.display = "none";
  redraw();
  updateZoomDisplay();
}
function deleteEdge(i) {
  edges.splice(i, 1);
  cfgPanel.style.display = "none";
  redraw();
  updateZoomDisplay();
}

function saveMap() {
  const data = { nodes, edges, groups };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = "node_map.json";
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{document.body.removeChild(a); URL.revokeObjectURL(url);}, 0);
}

function loadMap() {
  document.getElementById('jsonLoader').click();
}

document.getElementById('jsonLoader').addEventListener('change', function(e){
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    try {
      const obj = JSON.parse(evt.target.result);
      nodes = obj.nodes || [];
      edges = obj.edges || [];
      groups = obj.groups || [];
      redraw();
      updateZoomDisplay();
    } catch (err) {
      alert("Invalid or corrupt file!");
    }
  };
  reader.readAsText(file);
  this.value = '';
});

redraw();
updateZoomDisplay();
window.onresize = () => {
  svg.setAttribute("width", window.innerWidth);
  svg.setAttribute("height", window.innerHeight * 0.8);
  redraw();
  updateZoomDisplay();
};

svg.addEventListener("click", function(ev){
  if (connecting) {
    handleConnectClick(ev);
  }
});
async function exportToPDF() {
  try {
    const { jsPDF } = window.jspdf;
    const svgElement = document.getElementById("mapArea");

    // Clone SVG so we can style it without affecting the live one
    let clonedSvg = svgElement.cloneNode(true);

    // Inline styles for all text so html2canvas renders properly
    clonedSvg.querySelectorAll("text").forEach(text => {
      text.setAttribute("font-family", "sans-serif");
      text.setAttribute("fill", text.getAttribute("fill") || "#fff");
    });

    // Create wrapper for rendering
    let wrapper = document.createElement("div");
    wrapper.appendChild(clonedSvg);
    document.body.appendChild(wrapper);

    // Render the SVG wrapper to canvas
    const canvas = await html2canvas(wrapper, {
      backgroundColor: "#14213d",
      logging: false,
      useCORS: true
    });

    document.body.removeChild(wrapper);

    // Create PDF
    const imgData = canvas.toDataURL("image/png");
    const pdf = new jsPDF({
      orientation: "landscape",
      unit: "pt",
      format: [canvas.width, canvas.height]
    });
    pdf.addImage(imgData, "PNG", 0, 0, canvas.width, canvas.height);
    pdf.save("node_map.pdf");

  } catch (err) {
    console.error("PDF export failed", err);
    alert("Unable to export PDF. Check console for details.");
  }
}

</script>
</body>
</html>
