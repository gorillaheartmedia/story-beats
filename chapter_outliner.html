<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Chapter Outliner + Story Drafter</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>

<!-- Quill WYSIWYG Editor -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">

<!-- Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

<style>
body {
  margin: 0;
  font-family: 'Inter', Arial, sans-serif;
  background: linear-gradient(135deg, #143575 60%, #1958ca 100%);
  color: #eaf3ff;
}
h1,h2,h3 { margin:0; color:#fff; }

/* Header */
.header {
  background: rgba(24,39,70,0.98);
  padding: 16px 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1.5px solid #3b82f644;
}
.header-actions .btn { margin-left: 8px; }

/* Buttons */
.btn {
  background: linear-gradient(92deg, #3282f0, #2b71ea 80%);
  color: #fff;
  border: none;
  border-radius: 7px;
  font-weight: 600;
  font-size: 0.95em;
  padding: 7px 14px;
  cursor: pointer;
}
.btn:hover { background: linear-gradient(92deg, #2959de 0%, #60a5fa 100%); }

/* Layout */
.main-container {
  display: flex;
  height: calc(100vh - 70px);
}
.outliner {
  width: 280px;
  background: rgba(24,39,70,0.98);
  border-right: 1.5px solid #3b82f644;
  display: flex;
  flex-direction: column;
  padding: 12px;
}
.chapter-list { list-style:none; padding:0; margin:0; flex:1; overflow-y:auto; }
.chapter-item { background:#203a64b5; border-radius:8px; padding:10px; margin-bottom:8px; cursor:pointer; }
.chapter-title { font-weight:bold; }
.chapter-meta { font-size:0.85em; color:#aee5ff; display:flex; justify-content:space-between; margin-top:4px; }

/* Editor */
.editor-panel { flex:1; display:flex; flex-direction:column; padding:12px; }
.quill-editor { flex:1; background:#fff; color:#000; border-radius:6px; }
.quill-editor .ql-editor,
#drafterEditor .ql-editor {
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

/* Force wrapping in Quill editor, no matter the block type */
.quill-editor .ql-editor,
#drafterEditor .ql-editor,
.quill-editor .ql-editor *,
#drafterEditor .ql-editor * {
  white-space: pre-wrap !important;
  word-wrap: break-word !important;
  overflow-wrap: break-word !important;
}
/* Prevent horizontal overflow on editors */
.quill-editor,
#drafterEditor {
  overflow-x: hidden;
  max-width: 100%;
}

/* Wrap all text, even in code/pre blocks */
.quill-editor .ql-editor,
#drafterEditor .ql-editor,
.quill-editor .ql-editor *,
#drafterEditor .ql-editor * {
  white-space: pre-wrap !important;
  word-break: break-word !important;
  overflow-wrap: break-word !important;
}

/* Specific fix for Quill code blocks */
.ql-editor pre,
.ql-editor code {
  white-space: pre-wrap !important;
  word-break: break-word !important;
}

/* Story Drafter */
#storyDrafter { padding: 16px; }
#storyDrafter input { padding:6px; border-radius:4px; border:1px solid #284687; background:#19306a44; color:#fff; }
#drafterChapterList li { cursor:pointer; padding:6px; border-bottom:1px solid #234; }
#drafterChapterList li:hover { background:#2959de66; }

/* Floating Mic */
.fab-dictate {
  position: fixed; right: 32px; bottom: 32px; z-index: 9999;
  width: 62px; height: 62px; border-radius: 50%; cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  background: linear-gradient(130deg, #4befff 60%, #1958ca 100%);
}
.fab-dictate.active { background: linear-gradient(130deg, #ff4b4b 60%, #a30000 100%); }
</style>
</head>
<body>
<button><a href="project_core.html" class="btn">Return to Hub</a></button>
<header class="header">
  <h1>üìö Chapter Outliner</h1>
  <div class="header-actions">
    <button id="toggleModeBtn" class="btn">Switch to Story Drafter</button>
    <button id="exportPdfBtn" class="btn">üìÑ Export PDF</button>
    <button id="exportDocxBtn" class="btn">üìù Export Word</button>
    <button id="exportJsonBtn" class="btn">üíæ Export JSON</button>
    <input type="file" id="importJsonInput" accept=".json" hidden>
    <button id="importJsonBtn" class="btn">üìÇ Import JSON</button>
    <button id="openSprintBtn" class="btn">üèÉ Sprint</button>
    <button id="pasteSprintBtn" class="btn">üìã Paste Sprint</button>

  </div>
</header>

<!-- Outliner Mode -->
<main class="main-container" id="outlinerMode">
  <aside class="outliner">
    <button id="addChapterBtn" class="btn">‚ûï Add Chapter</button>
    <ul id="chapterList" class="chapter-list"></ul>
  </aside>
  <section class="editor-panel">
    <div id="editorToolbar"></div>
    <div id="editor" class="quill-editor"></div>
    <div class="meta-section">
      <label>Summary</label>
      <textarea id="chapterSummary"></textarea>
      <label>Tags (comma-separated)</label>
      <input type="text" id="chapterTags">
    </div>
  </section>
</main>

<!-- Story Drafter Mode -->
<section id="storyDrafter" style="display:none;">
  <h2>‚úçÔ∏è Story Drafter</h2>
  <label>Story Title</label>
  <input type="text" id="storyTitle" style="width:100%; margin-bottom:10px;">
  <label>Author Name</label>
  <input type="text" id="storyAuthor" style="width:100%; margin-bottom:20px;">

  <div style="display:flex; gap:20px;">
    <aside style="flex:1; background:#14283c; padding:10px; border-radius:6px; max-width:250px;">
      <h3>Chapters</h3>
      <ul id="drafterChapterList" style="list-style:none; padding:0; margin:0;"></ul>
    </aside>

    <div style="flex:3; display:flex; flex-direction:column;">
      <div id="drafterToolbar"></div>
      <div id="drafterEditor" style="background:white; color:black; min-height:300px;"></div>
      <div style="margin-top:10px;">
        <button id="drafterDictateBtn" class="btn" style="background:#4befff; color:black;">üé§ Dictate</button>
        <button id="saveDraftBtn" class="btn">üíæ Save Draft</button>
      </div>
    </div>
  </div>
</section>

<!-- Floating mic for Outliner -->
<div id="dictateFab" class="fab-dictate" data-tooltip="Start Dictation">
  <i class="fas fa-microphone"></i>
</div>
<!-- Scripts -->
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://unpkg.com/docx@8.2.2/build/index.umd.js"></script>
<script>
  let storedProject = JSON.parse(localStorage.getItem("currentProject") || "null");
let projectId = storedProject?.id || localStorage.getItem("currentProjectId") || "defaultProject";
let chapters = JSON.parse(localStorage.getItem("chapters_" + projectId) || "[]");
let activeChapterIndex = 0;
let quill, drafterQuill;
let storyMode = localStorage.getItem("storyMode") || "outliner";
let activeDraftChapter = null;

// Sprint button setup
const sprintBtn = document.getElementById("openSprintBtn");
if (sprintBtn) {
  sprintBtn.textContent = `üèÉ Sprint for ${projectId}`;
  sprintBtn.addEventListener("click", () => {
    const sprintUrl = `sprint.html?projectId=${encodeURIComponent(projectId)}`;
    window.open(sprintUrl, "_blank");
  });
}

const starterChapters = [
  { id: crypto.randomUUID(), title: "Chapter 1 ‚Äì The Gate", summary: "", tags: [], status: "Draft", bodyHtml: "" }
];

function saveChapters() {
  localStorage.setItem("chapters_" + projectId, JSON.stringify(chapters));
}

function renderChapters() {
  const list = document.getElementById("chapterList");
  list.innerHTML = "";
  chapters.forEach((ch, idx) => {
    const li = document.createElement("li");
    li.className = "chapter-item";
    li.innerHTML = `<div class="chapter-title">${ch.title}</div>
                    <div class="chapter-meta"><span>${ch.status}</span><span>${getWordCount(ch.bodyHtml)} words</span></div>`;
    li.addEventListener("click", () => loadChapter(idx));
    list.appendChild(li);
  });
}

function getWordCount(html) {
  return html.replace(/<[^>]*>/g, ' ').trim().split(/\s+/).filter(w => w).length;
}

function loadChapter(index) {
  activeChapterIndex = index;
  quill.root.innerHTML = chapters[index].bodyHtml;
  document.getElementById("chapterSummary").value = chapters[index].summary || "";
  document.getElementById("chapterTags").value = (chapters[index].tags || []).join(", ");
}

document.getElementById("addChapterBtn").addEventListener("click", () => {
  chapters.push({ id: crypto.randomUUID(), title: `New Chapter ${chapters.length+1}`, summary: "", tags: [], status: "Draft", bodyHtml: "" });
  saveChapters();
  renderChapters();
});

function initQuillEditors() {
  quill = new Quill('#editor', {
    theme: 'snow',
    modules: { toolbar: [['bold','italic','underline'],[{header:[1,2,false]}],[{list:'ordered'},{list:'bullet'}],['blockquote','link','image'],['clean']] }
  });
  quill.on('text-change', () => {
    chapters[activeChapterIndex].bodyHtml = quill.root.innerHTML;
    saveChapters();
  });

  drafterQuill = new Quill('#drafterEditor', {
    theme: 'snow',
    modules: { toolbar: [['bold','italic','underline'],[{header:[1,2,false]}],[{list:'ordered'},{list:'bullet'}],['blockquote','link','image'],['clean']] }
  });
}
document.getElementById("toggleModeBtn").addEventListener("click", () => {
  if (storyMode === "outliner") switchToStoryMode(); else switchToOutlinerMode();
});

function switchToStoryMode() {
  document.getElementById("outlinerMode").style.display = "none";
  document.getElementById("storyDrafter").style.display = "block";
  document.getElementById("toggleModeBtn").textContent = "Switch to Chapter Outliner";
  storyMode = "drafter";
  localStorage.setItem("storyMode", "drafter");
  renderDrafterChapters();
}

function switchToOutlinerMode() {
  document.getElementById("outlinerMode").style.display = "flex";
  document.getElementById("storyDrafter").style.display = "none";
  document.getElementById("toggleModeBtn").textContent = "Switch to Story Drafter";
  storyMode = "outliner";
  localStorage.setItem("storyMode", "outliner");
}

function renderDrafterChapters() {
  const list = document.getElementById("drafterChapterList");
  list.innerHTML = "";
  chapters.forEach((ch, idx) => {
    const li = document.createElement("li");
    li.textContent = ch.title;
    li.addEventListener("click", () => loadDraftChapter(idx));
    list.appendChild(li);
  });
}

function loadDraftChapter(index) {
  activeDraftChapter = index;
  drafterQuill.root.innerHTML = chapters[index].bodyHtml || "";
}

document.getElementById("saveDraftBtn").addEventListener("click", () => {
  if (activeDraftChapter !== null) {
    chapters[activeDraftChapter].bodyHtml = drafterQuill.root.innerHTML;
    saveChapters();
    alert("Draft saved!");
  }
});

// Dictation for Outliner
let recognition, isDictating = false, lastResultIndex = -1;
function initDictation() {
  if (!('webkitSpeechRecognition' in window)) { alert("Speech Recognition not supported."); return; }
  recognition = new webkitSpeechRecognition();
  recognition.lang = "en-US";
  recognition.continuous = true;
  recognition.interimResults = true;
  recognition.onresult = e => {
    for (let i = e.resultIndex; i < e.results.length; ++i) {
      if (e.results[i].isFinal && i !== lastResultIndex) {
        lastResultIndex = i;
        let t = e.results[i][0].transcript.replace(/\bcomma\b/gi,",").replace(/\bperiod\b/gi,".").replace(/\bquestion mark\b/gi,"?").replace(/\bnew line\b/gi,"\n");
        const pos = quill.getSelection(true).index;
        quill.insertText(pos, t + " ");
        quill.setSelection(pos + t.length + 1);
      }
    }
  };
}
document.getElementById("dictateFab").addEventListener("click", () => {
  if (!recognition) initDictation();
  if (isDictating) { recognition.stop(); isDictating = false; document.getElementById("dictateFab").classList.remove("active"); }
  else { lastResultIndex = -1; recognition.start(); isDictating = true; document.getElementById("dictateFab").classList.add("active"); }
});

// Dictation for Drafter
let drafterRecognition, isDrafterDictating = false, drafterLastResultIndex = -1;
function initDrafterDictation() {
  if (!('webkitSpeechRecognition' in window)) { alert("Speech Recognition not supported."); return; }
  drafterRecognition = new webkitSpeechRecognition();
  drafterRecognition.lang = "en-US";
  drafterRecognition.continuous = true;
  drafterRecognition.interimResults = true;
  drafterRecognition.onresult = e => {
    for (let i = e.resultIndex; i < e.results.length; ++i) {
      if (e.results[i].isFinal && i !== drafterLastResultIndex) {
        drafterLastResultIndex = i;
        let t = e.results[i][0].transcript.replace(/\bcomma\b/gi,",").replace(/\bperiod\b/gi,".").replace(/\bquestion mark\b/gi,"?").replace(/\bnew line\b/gi,"\n");
        const pos = drafterQuill.getSelection(true).index;
        drafterQuill.insertText(pos, t + " ");
        drafterQuill.setSelection(pos + t.length + 1);
      }
    }
  };
}
document.getElementById("drafterDictateBtn").addEventListener("click", () => {
  if (!drafterRecognition) initDrafterDictation();
  if (isDrafterDictating) { drafterRecognition.stop(); isDrafterDictating = false; document.getElementById("drafterDictateBtn").textContent = "üé§ Dictate"; }
  else { drafterLastResultIndex = -1; drafterRecognition.start(); isDrafterDictating = true; document.getElementById("drafterDictateBtn").textContent = "‚èπ Stop Dictation"; }
});

// PDF Export
document.getElementById("exportPdfBtn").addEventListener("click", () => {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.setFontSize(18);
  doc.text("Project: " + projectId, 10, 20);
  chapters.forEach(ch => {
    doc.addPage();
    doc.setFontSize(16).text(ch.title, 10, 20);
    const div = document.createElement("div");
    div.innerHTML = ch.bodyHtml;
    doc.setFontSize(12).text(div.innerText, 10, 30);
  });
  doc.save("chapters.pdf");
});

// DOCX Export (Story Drafter gets book style)
document.getElementById("exportDocxBtn").addEventListener("click", async () => {
  const { Document, Packer, Paragraph, HeadingLevel, TextRun, AlignmentType } = window.docx;

  if (storyMode === "drafter") {
    const storyTitle = document.getElementById("storyTitle").value || "Untitled Story";
    const storyAuthor = document.getElementById("storyAuthor").value || "";

    const sections = [];
    sections.push({
      children: [
        new Paragraph({ text: storyTitle, heading: HeadingLevel.TITLE, alignment: AlignmentType.CENTER, spacing: { before: 3000 } }),
        new Paragraph({ text: storyAuthor ? `by ${storyAuthor}` : "", alignment: AlignmentType.CENTER, spacing: { before: 300 } })
      ]
    });

    const tocParas = [ new Paragraph({ text: "Table of Contents", heading: HeadingLevel.HEADING_1 }) ];
    let currentPage = 3;
    chapters.forEach(ch => {
      tocParas.push(new Paragraph({ children: [
        new TextRun({ text: ch.title, bold: true }),
        new TextRun({ text: `  .......  ${currentPage}`, break: 1 })
      ]}));
      currentPage++;
    });
    sections.push({ children: tocParas });

    chapters.forEach(ch => {
      const paras = [ new Paragraph({ text: ch.title, heading: HeadingLevel.HEADING_1 }) ];
      const div = document.createElement("div");
      div.innerHTML = ch.bodyHtml;
      div.innerText.split("\n").forEach(line => paras.push(new Paragraph(line)));
      sections.push({ children: paras });
    });

    const docxFile = new Document({ sections });
    const blob = await Packer.toBlob(docxFile);
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${storyTitle.replace(/\s+/g, "_")}.docx`;
    link.click();

  } else {
    const sections = chapters.map(ch => {
      const paras = [ new Paragraph({ text: ch.title, heading: HeadingLevel.HEADING_1 }) ];
      const div = document.createElement("div");
      div.innerHTML = ch.bodyHtml;
      div.innerText.split("\n").forEach(line => paras.push(new Paragraph(line)));
      return { children: paras };
    });
    const docxFile = new Document({ sections });
    const blob = await Packer.toBlob(docxFile);
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${projectId}_chapters.docx`;
    link.click();
  }
});

// JSON Import/Export
document.getElementById("exportJsonBtn").addEventListener("click", () => {
  const blob = new Blob([JSON.stringify(chapters, null, 2)], {type: "application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = projectId + "_chapters.json";
  a.click();
});
document.getElementById("importJsonBtn").addEventListener("click", () => document.getElementById("importJsonInput").click());
document.getElementById("importJsonInput").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => { chapters = JSON.parse(evt.target.result); saveChapters(); renderChapters(); };
  reader.readAsText(file);
});

window.addEventListener("load", () => {
  if (chapters.length === 0) { chapters = starterChapters; saveChapters(); }
  initQuillEditors();
  renderChapters();
  if (storyMode === "drafter") switchToStoryMode();
});

function renderChapters() {
  const list = document.getElementById("chapterList");
  list.innerHTML = "";
  chapters.forEach((ch, idx) => {
    const li = document.createElement("li");
    li.className = "chapter-item";

    const titleDiv = document.createElement("div");
    titleDiv.className = "chapter-title";
    titleDiv.textContent = ch.title;
    titleDiv.addEventListener("click", () => loadChapter(idx));

    const metaDiv = document.createElement("div");
    metaDiv.className = "chapter-meta";
    metaDiv.innerHTML = `<span>${ch.status}</span><span>${getWordCount(ch.bodyHtml)} words</span>`;

    const delBtn = document.createElement("button");
    delBtn.textContent = "üóë";
    delBtn.className = "btn";
    delBtn.style.background = "#b91c1c";
    delBtn.style.padding = "2px 6px";
    delBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (confirm(`Delete chapter "${ch.title}"?`)) {
        chapters.splice(idx, 1);
        saveChapters();
        renderChapters();
        renderDrafterChapters();
      }
    });

    li.appendChild(titleDiv);
    li.appendChild(metaDiv);
    li.appendChild(delBtn);
    list.appendChild(li);
  });
}
document.getElementById("pasteSprintBtn").addEventListener("click", async () => {
  try {
    const text = await navigator.clipboard.readText();
    if (!text) {
      alert("Clipboard is empty.");
      return;
    }
    const pos = drafterQuill.getSelection(true).index;
    drafterQuill.insertText(pos, text + "\n");
    drafterQuill.setSelection(pos + text.length + 1);
    alert("Sprint text pasted!");
  } catch (err) {
    console.error(err);
    alert("Unable to read clipboard. Check browser permissions.");
  }
});

</script>
</body>
</html>
